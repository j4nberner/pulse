<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ICU Time-Series Prediction Benchmark</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        color: #333;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 30px;
        margin-bottom: 30px;
        text-align: center;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      }

      .header h1 {
        font-size: 2.5em;
        background: linear-gradient(135deg, #667eea, #764ba2);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 10px;
      }

      .header-content {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 20px;
        margin-bottom: 20px;
      }

      .pulse-logo {
        height: 60px;
        width: auto;
      }

      .gold-cup {
        color: #ffd700;
        font-size: 1.2em;
        margin-left: 8px;
        display: inline-block;
        animation: sparkle 2s ease-in-out infinite;
      }

      @keyframes sparkle {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      .header p {
        font-size: 1.2em;
        color: #666;
        margin-bottom: 20px;
      }

      .controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 20px;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
      }

      .control-group label {
        font-weight: 600;
        color: #555;
        font-size: 0.9em;
      }

      select,
      input {
        padding: 10px 15px;
        border: 2px solid #e0e0e0;
        border-radius: 10px;
        background: white;
        font-size: 14px;
        transition: all 0.3s ease;
        min-width: 120px;
      }

      select:focus,
      input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      .dashboard {
        display: grid;
        gap: 25px;
        grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
      }

      .card {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 25px;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }

      .card:hover {
        transform: translateY(-5px);
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
      }

      .card h3 {
        font-size: 1.4em;
        margin-bottom: 20px;
        color: #333;
        text-align: center;
        padding-bottom: 10px;
        border-bottom: 2px solid #f0f0f0;
      }

      .chart-container {
        position: relative;
        height: 400px;
        margin-bottom: 20px;
      }

      .table-container {
        overflow-x: auto;
        margin-top: 20px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        background: white;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
      }

      th,
      td {
        padding: 12px 15px;
        text-align: left;
        border-bottom: 1px solid #f0f0f0;
      }

      th {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        font-weight: 600;
        text-transform: uppercase;
        font-size: 0.85em;
        letter-spacing: 0.5px;
      }

      tr:hover {
        background-color: #f8f9ff;
      }

      .metric-value {
        font-weight: 600;
        padding: 4px 8px;
        border-radius: 6px;
        display: inline-block;
        min-width: 60px;
        text-align: center;
      }

      .metric-high {
        background: linear-gradient(135deg, #4facfe, #00f2fe);
        color: white;
      }

      .metric-medium {
        background: linear-gradient(135deg, #43e97b, #38f9d7);
        color: white;
      }

      .metric-low {
        background: linear-gradient(135deg, #fa709a, #fee140);
        color: white;
      }

      .summary-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin-bottom: 25px;
      }

      .stat-card {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 20px;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
      }

      .stat-value {
        font-size: 2em;
        font-weight: bold;
        margin-bottom: 5px;
      }

      .stat-label {
        font-size: 0.9em;
        opacity: 0.9;
      }

      .model-type-badge {
        display: inline-block;
        padding: 4px 10px;
        border-radius: 15px;
        font-size: 0.8em;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .llm-badge {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
      }

      .baseline-badge {
        background: linear-gradient(135deg, #ffecd2, #fcb69f);
        color: #8b4513;
      }

      .loading {
        text-align: center;
        padding: 50px;
        font-size: 1.2em;
        color: #666;
      }

      .no-data {
        text-align: center;
        padding: 40px;
        color: #888;
        font-style: italic;
      }

      /* Medical Context Styles */
      .medical-context {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 25px;
        margin-bottom: 25px;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
      }

      .context-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
      }

      .context-card {
        background: linear-gradient(135deg, #f8fafc, #e2e8f0);
        border-radius: 15px;
        padding: 20px;
        text-align: center;
        transition: transform 0.3s ease;
      }

      .context-card:hover {
        transform: translateY(-5px);
      }

      .context-icon {
        font-size: 2.5em;
        margin-bottom: 15px;
      }

      .context-card h4 {
        color: #1e40af;
        margin-bottom: 10px;
        font-size: 1.1em;
      }

      .context-card p {
        color: #64748b;
        font-size: 0.9em;
        line-height: 1.5;
      }

      /* Clinical Notice Styles */
      .clinical-notice {
        background: linear-gradient(135deg, #fef3c7, #fbbf24);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 25px;
        border-left: 5px solid #f59e0b;
      }

      .notice-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }

      .notice-icon {
        font-size: 1.2em;
      }

      .clinical-notice p {
        color: #92400e;
        font-size: 0.9em;
        line-height: 1.5;
        margin: 0;
      }

      /* Medical Metrics Styles */
      .medical-metrics-info {
        background: #f8fafc;
        border-radius: 10px;
        padding: 20px;
      }

      .metric-explanations {
        display: grid;
        gap: 12px;
      }

      .metric-explanation {
        background: white;
        padding: 12px 15px;
        border-radius: 8px;
        border-left: 4px solid #3b82f6;
        font-size: 0.9em;
      }

      .metric-explanation strong {
        color: #1e40af;
      }

      /* Dataset Grid Styles */
      .dataset-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
      }

      .dataset-info {
        background: linear-gradient(135deg, #f1f5f9, #e2e8f0);
        border-radius: 12px;
        padding: 20px;
        border-top: 4px solid #3b82f6;
      }

      .dataset-info h4 {
        color: #1e40af;
        margin-bottom: 15px;
        font-size: 1.2em;
        text-align: center;
      }

      .dataset-info p {
        margin-bottom: 8px;
        font-size: 0.9em;
        line-height: 1.4;
      }

      .dataset-info strong {
        color: #475569;
      }

      /* Enhanced Medical Color Scheme */
      :root {
        --medical-blue: #1e3a8a;
        --medical-green: #16a34a;
        --medical-red: #dc2626;
        --clinical-gray: #64748b;
        --trust-blue: #3b82f6;
        --warning-yellow: #f59e0b;
      }

      .metric-high {
        background: linear-gradient(135deg, var(--medical-green), #22c55e);
        color: white;
      }

      .metric-medium {
        background: linear-gradient(135deg, var(--warning-yellow), #fbbf24);
        color: white;
      }

      .metric-low {
        background: linear-gradient(135deg, var(--medical-red), #ef4444);
        color: white;
      }

      /* Mobile Responsiveness for Medical Content */
      @media (max-width: 768px) {
        .medical-context {
          padding: 15px;
        }
        
        .context-cards {
          grid-template-columns: 1fr;
          gap: 15px;
        }
        
        .dataset-grid {
          grid-template-columns: 1fr;
        }
        
        .context-card, .dataset-info {
          padding: 15px;
        }
        
        /* Larger touch targets for clinical use */
        select, button {
          min-height: 44px;
          font-size: 16px;
        }

        .dashboard {
          grid-template-columns: 1fr;
        }

        .controls {
          flex-direction: column;
          align-items: stretch;
        }

        .control-group {
          align-items: stretch;
        }

        .header-content {
          flex-direction: column;
          gap: 10px;
        }

        .header h1 {
          font-size: 2em;
          text-align: center;
        }

        .pulse-logo {
          height: 40px;
        }

        .context-cards {
          grid-template-columns: 1fr;
        }

        .dataset-grid {
          grid-template-columns: 1fr;
        }
      }

      /* Research Footer Styles */
      .research-footer {
        background: linear-gradient(135deg, #1e293b, #334155);
        color: white;
        border-radius: 20px;
        padding: 30px;
        margin-top: 30px;
        text-align: center;
      }

      .research-footer h4 {
        color: #e2e8f0;
        margin-bottom: 15px;
        font-size: 1.3em;
      }

      .research-footer p {
        color: #cbd5e1;
        line-height: 1.6;
        margin-bottom: 25px;
      }

      .research-highlights {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin: 25px 0;
      }

      .highlight-item {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 20px;
        text-align: left;
      }

      .highlight-icon {
        font-size: 1.5em;
        margin-right: 10px;
      }

      .highlight-item strong {
        color: #60a5fa;
        display: block;
        margin-bottom: 5px;
      }

      .research-links {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 25px;
      }

      .research-btn {
        background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        color: white;
        padding: 12px 20px;
        border-radius: 10px;
        text-decoration: none;
        font-weight: 600;
        transition: all 0.3s ease;
        border: none;
        cursor: pointer;
      }

      .research-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(59, 130, 246, 0.3);
      }

      @media (max-width: 768px) {
        .research-highlights {
          grid-template-columns: 1fr;
        }
        
        .research-links {
          flex-direction: column;
          align-items: stretch;
        }
        
        .research-btn {
          text-align: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="header-content">
          <img src="pulse_logo.svg" alt="PULSE Logo" class="pulse-logo" />
          <h1>ICU Time-Series Prediction Benchmark</h1>
        </div>
        <p>
          Comprehensive comparison of LLMs and baseline models on ICU prediction
          tasks
        </p>

        <div class="controls">
          <div class="control-group">
            <label>Task</label>
            <select id="taskFilter">
              <option value="all">All Tasks</option>
            </select>
          </div>
          <div class="control-group">
            <label>Dataset</label>
            <select id="datasetFilter">
              <option value="all">All Datasets</option>
            </select>
          </div>
          <div class="control-group">
            <label>Model Type</label>
            <select id="modelTypeFilter">
              <option value="all">All Models</option>
              <option value="llm">LLMs Only</option>
              <option value="baseline">Baselines Only</option>
            </select>
          </div>
          <div class="control-group">
            <label>Primary Metric</label>
            <select id="primaryMetric">
              <option value="auroc">AUROC</option>
              <option value="auprc">AUPRC</option>
              <option value="mcc">MCC</option>
              <option value="f1_score">F1 Score</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Medical Context Section -->
      <div class="medical-context">
        <div class="context-cards">
          <div class="context-card">
            <div class="context-icon">🏥</div>
            <h4>Clinical Impact</h4>
            <p>Evaluating AI models for critical care decision support in real ICU environments</p>
          </div>
          <div class="context-card">
            <div class="context-icon">⚡</div>
            <h4>Time-Critical</h4>
            <p>Performance metrics reflect real-time prediction capabilities for patient outcomes</p>
          </div>
          <div class="context-card">
            <div class="context-icon">📊</div>
            <h4>Multi-Dataset</h4>
            <p>Validated across MIMIC-IV, eICU, and HiRID for generalizability</p>
          </div>
        </div>
      </div>

      <!-- Clinical Validation Notice -->
      <div class="clinical-notice">
        <div class="notice-header">
          <span class="notice-icon">⚠️</span>
          <strong>Clinical Validation Notice</strong>
        </div>
        <p>These models are for research purposes only. Clinical deployment requires additional validation, regulatory approval, and integration with existing clinical workflows.</p>
      </div>

      <div class="summary-stats" id="summaryStats">
        <div class="stat-card">
          <div class="stat-value" id="totalModels">-</div>
          <div class="stat-label">Total Models</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="totalTasks">-</div>
          <div class="stat-label">Tasks</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="totalDatasets">-</div>
          <div class="stat-label">Datasets</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="bestModel">-</div>
          <div class="stat-label">Best Model</div>
        </div>
      </div>

      <div class="dashboard">
        <div class="card">
          <h3>Model Performance Comparison</h3>
          <div class="chart-container">
            <canvas id="performanceChart"></canvas>
          </div>
        </div>

        <div class="card">
          <h3>Task-wise Performance</h3>
          <div class="chart-container">
            <canvas id="taskChart"></canvas>
          </div>
        </div>

        <div class="card">
          <h3>LLM vs Baseline Comparison</h3>
          <div class="chart-container">
            <canvas id="comparisonChart"></canvas>
          </div>
        </div>

        <div class="card">
          <h3>Detailed Results Table</h3>
          <div class="table-container">
            <table id="resultsTable">
              <thead>
                <tr>
                  <th>Model</th>
                  <th>Type</th>
                  <th>Task</th>
                  <th>Dataset</th>
                  <th>AUROC</th>
                  <th>AUPRC</th>
                  <th>MCC</th>
                  <th>F1 Score</th>
                </tr>
              </thead>
              <tbody id="resultsTableBody">
                <tr>
                  <td colspan="8" class="loading">
                    Load your JSON data to see results
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <h3>Clinical Metrics Interpretation</h3>
          <div class="medical-metrics-info">
            <div class="metric-explanations">
              <div class="metric-explanation">
                <strong>AUROC ≥ 0.8:</strong> Excellent discriminative ability for clinical use
              </div>
              <div class="metric-explanation">
                <strong>AUPRC ≥ 0.7:</strong> Good precision-recall balance for rare events
              </div>
              <div class="metric-explanation">
                <strong>MCC ≥ 0.5:</strong> Strong correlation accounting for class imbalance
              </div>
              <div class="metric-explanation">
                <strong>F1 ≥ 0.7:</strong> Balanced precision and recall for clinical decisions
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <h3>Dataset Characteristics</h3>
          <div class="dataset-grid">
            <div class="dataset-info">
              <h4>MIMIC-IV</h4>
              <p><strong>Source:</strong> Beth Israel Deaconess Medical Center</p>
              <p><strong>Patients:</strong> ~380,000 patients</p>
              <p><strong>Time Period:</strong> 2008-2019</p>
              <p><strong>Specialty:</strong> Multi-department ICU data</p>
            </div>
            <div class="dataset-info">
              <h4>eICU</h4>
              <p><strong>Source:</strong> Multi-center collaborative</p>
              <p><strong>Patients:</strong> ~200,000 ICU stays</p>
              <p><strong>Hospitals:</strong> 208 hospitals</p>
              <p><strong>Specialty:</strong> Diverse ICU environments</p>
            </div>
            <div class="dataset-info">
              <h4>HiRID</h4>
              <p><strong>Source:</strong> University Hospital Zurich</p>
              <p><strong>Patients:</strong> ~33,000 patients</p>
              <p><strong>Resolution:</strong> High-frequency (2-min intervals)</p>
              <p><strong>Specialty:</strong> High-resolution physiological data</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Research Context Footer -->
      <div class="research-footer">
        <h4>Research Background</h4>
        <p>This benchmark is part of ongoing research in AI-assisted critical care. Our evaluation framework considers both technical performance and clinical applicability for real-world ICU deployment.</p>
        <div class="research-highlights">
          <div class="highlight-item">
            <span class="highlight-icon">🔬</span>
            <strong>Rigorous Methodology:</strong> Standardized evaluation protocols across multiple ICU datasets
          </div>
          <div class="highlight-item">
            <span class="highlight-icon">📊</span>
            <strong>Clinical Metrics:</strong> Performance thresholds based on medical literature and expert consensus
          </div>
          <div class="highlight-item">
            <span class="highlight-icon">🏥</span>
            <strong>Real-World Focus:</strong> Evaluation considers deployment constraints and clinical workflows
          </div>
        </div>
        <div class="research-links">
          <a href="#" class="research-btn">📄 Read Paper</a>
          <a href="#" class="research-btn">💾 Download Data</a>
          <a href="#" class="research-btn">🔬 Methodology</a>
          <a href="#" class="research-btn">📧 Contact Team</a>
        </div>
      </div>
    </div>

    <script>
      console.log("Script loaded successfully");
      let benchmarkData = [];
      let charts = {};

      // Medical task descriptions with clinical context
      const medicalTaskDescriptions = {
        'mortality': {
          name: 'In-Hospital Mortality Prediction',
          description: 'Predicting patient mortality risk within 24-48 hours',
          clinicalRelevance: 'Early warning system for high-risk patients',
          prevalence: '~8-12% in ICU populations'
        },
        'aki': {
          name: 'Acute Kidney Injury (AKI)',
          description: 'Predicting onset of kidney dysfunction',
          clinicalRelevance: 'Enable early intervention to prevent progression',
          prevalence: '~20-25% of ICU admissions'
        },
        'sepsis': {
          name: 'Sepsis Detection',
          description: 'Early identification of septic shock',
          clinicalRelevance: 'Critical for timely antibiotic administration',
          prevalence: '~15-20% of ICU patients'
        },
        'los': {
          name: 'Length of Stay Prediction',
          description: 'Predicting extended ICU stay duration',
          clinicalRelevance: 'Resource planning and bed management',
          prevalence: 'Variable by ICU type'
        }
      };

      // Clinical acceptability thresholds
      const clinicalThresholds = {
        'auroc': 0.8,  // Minimum for clinical consideration
        'auprc': 0.7,  // Good precision-recall balance
        'mcc': 0.5,    // Strong correlation
        'f1_score': 0.7 // Balanced precision and recall
      };

      // Baseline model identifiers
      const baselineModels = [
        "CNN",
        "LSTM",
        "GRU",
        "XGBoost",
        "LightGBM",
        "RandomForest",
        "Inceptiontime",
      ];

      function isBaselineModel(modelId) {
        return baselineModels.some((baseline) =>
          modelId.toLowerCase().includes(baseline.toLowerCase())
        );
      }

      function getModelType(modelId) {
        return isBaselineModel(modelId) ? "baseline" : "llm";
      }

      // Auto-load results.json on page load
      async function loadResultsJSON() {
        console.log("Attempting to load results.json...");
        try {
          const response = await fetch("results.json");
          console.log("Fetch response:", response);
          console.log("Response status:", response.status);
          console.log("Response ok:", response.ok);

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          console.log("Data loaded successfully:", data);
          console.log("Data type:", typeof data);
          console.log("Is array?", Array.isArray(data));
          console.log("Has results property?", data.hasOwnProperty("results"));

          // Handle both array format and {results: [...]} format
          if (Array.isArray(data)) {
            benchmarkData = data;
            console.log("Using data directly as array");
          } else if (data.results && Array.isArray(data.results)) {
            benchmarkData = data.results;
            console.log("Using data.results as array");
          } else {
            throw new Error(
              "Invalid JSON format. Expected array or {results: [...]}"
            );
          }

          console.log("Benchmark data:", benchmarkData);
          console.log("Benchmark data length:", benchmarkData.length);
          initializeDashboard();
        } catch (error) {
          console.error("Error loading results.json:", error);

          // Show error message in the table
          const tbody = document.getElementById("resultsTableBody");
          tbody.innerHTML = `
                    <tr>
                        <td colspan="8" class="no-data">
                            Error loading results.json: ${error.message}<br>
                            Please ensure results.json is in the same folder as index.html
                        </td>
                    </tr>
                `;

          // Also show in summary stats
          document.getElementById("totalModels").textContent = "Error";
          document.getElementById("totalTasks").textContent = "Error";
          document.getElementById("totalDatasets").textContent = "Error";
          document.getElementById("bestModel").textContent = "Error";
        }
      }

      // Load data when page loads
      window.addEventListener("load", () => {
        console.log("Window load event fired");
        loadResultsJSON();
      });

      function initializeDashboard() {
        console.log("Initializing dashboard with data:", benchmarkData);
        console.log("Data length:", benchmarkData.length);
        populateFilters();
        updateSummaryStats();
        createCharts();
        updateTable();
        setupEventListeners();
      }

      function populateFilters() {
        console.log("Populating filters with data:", benchmarkData);

        // Filter out any entries with missing task_id or dataset and log them
        const validData = benchmarkData.filter((d, index) => {
          if (!d.task_id || !d.dataset) {
            console.warn(`Entry ${index} missing required fields:`, d);
            return false;
          }
          return true;
        });

        console.log(
          "Valid data count:",
          validData.length,
          "out of",
          benchmarkData.length
        );

        const tasks = [...new Set(validData.map((d) => d.task_id))];
        const datasets = [...new Set(validData.map((d) => d.dataset))];

        console.log("Unique tasks:", tasks);
        console.log("Unique datasets:", datasets);

        const taskFilter = document.getElementById("taskFilter");
        const datasetFilter = document.getElementById("datasetFilter");

        taskFilter.innerHTML = '<option value="all">All Tasks</option>';
        datasetFilter.innerHTML = '<option value="all">All Datasets</option>';

        tasks.forEach((task) => {
          if (task) {
            // Additional safety check
            taskFilter.innerHTML += `<option value="${task}">${
              task.charAt(0).toUpperCase() + task.slice(1)
            }</option>`;
          }
        });

        datasets.forEach((dataset) => {
          if (dataset) {
            // Additional safety check
            datasetFilter.innerHTML += `<option value="${dataset}">${dataset.toUpperCase()}</option>`;
          }
        });
      }

      function getFilteredData() {
        const taskFilter = document.getElementById("taskFilter").value;
        const datasetFilter = document.getElementById("datasetFilter").value;
        const modelTypeFilter =
          document.getElementById("modelTypeFilter").value;

        return benchmarkData.filter((d) => {
          // Safety checks for undefined values
          if (!d.task_id || !d.dataset || !d.model_id) {
            return false;
          }

          const taskMatch = taskFilter === "all" || d.task_id === taskFilter;
          const datasetMatch =
            datasetFilter === "all" || d.dataset === datasetFilter;
          const modelType = getModelType(d.model_id);
          const modelTypeMatch =
            modelTypeFilter === "all" || modelType === modelTypeFilter;

          return taskMatch && datasetMatch && modelTypeMatch;
        });
      }

      function updateSummaryStats() {
        const filteredData = getFilteredData();
        const models = [...new Set(filteredData.map((d) => d.model_id))];
        const tasks = [...new Set(filteredData.map((d) => d.task_id))];
        const datasets = [...new Set(filteredData.map((d) => d.dataset))];

        const primaryMetric = document.getElementById("primaryMetric").value;
        console.log(
          "Updating summary stats with primary metric:",
          primaryMetric
        );

        // Debug: Log all scores for the selected metric
        const allScores = filteredData.map((d) => ({
          model: d.model_id,
          score: d.metrics_summary?.overall?.[primaryMetric],
          rawMetrics: d.metrics_summary?.overall,
        }));
        console.log(`All ${primaryMetric} scores:`, allScores);

        const bestResult = filteredData.reduce((best, current) => {
          const currentScore =
            current.metrics_summary?.overall?.[primaryMetric];
          const bestScore = best?.metrics_summary?.overall?.[primaryMetric];

          // Handle cases where scores might be null/undefined
          if (currentScore === undefined || currentScore === null) return best;
          if (best === null || bestScore === undefined || bestScore === null)
            return current;

          return currentScore > bestScore ? current : best;
        }, null);

        // Alternative approach: Find the model with the highest average score
        const modelAverages = {};
        filteredData.forEach((d) => {
          const score = d.metrics_summary?.overall?.[primaryMetric];
          if (score !== undefined && score !== null) {
            if (!modelAverages[d.model_id]) {
              modelAverages[d.model_id] = { scores: [], entries: [] };
            }
            modelAverages[d.model_id].scores.push(score);
            modelAverages[d.model_id].entries.push(d);
          }
        });

        // Find model with highest average score
        let bestModelByAverage = null;
        let bestAverageScore = -Infinity;
        Object.keys(modelAverages).forEach((modelId) => {
          const scores = modelAverages[modelId].scores;
          const avgScore =
            scores.reduce((sum, score) => sum + score, 0) / scores.length;
          if (avgScore > bestAverageScore) {
            bestAverageScore = avgScore;
            bestModelByAverage = modelId;
          }
        });

        console.log(
          "Best result by single entry:",
          bestResult?.model_id,
          "with score:",
          bestResult?.metrics_summary?.overall?.[primaryMetric]
        );
        console.log(
          "Best model by average score:",
          bestModelByAverage,
          "with avg score:",
          bestAverageScore
        );

        // Use the model with best average score for display
        const displayBestModel = bestModelByAverage || bestResult?.model_id;

        document.getElementById("totalModels").textContent = models.length;
        document.getElementById("totalTasks").textContent = tasks.length;
        document.getElementById("totalDatasets").textContent = datasets.length;

        // Display best model with gold cup
        const bestModelElement = document.getElementById("bestModel");
        if (displayBestModel) {
          bestModelElement.innerHTML = `${displayBestModel} <span class="gold-cup">🏆</span>`;
        } else {
          bestModelElement.textContent = "-";
        }
      }

      async function createCharts() {
        await createPerformanceChart();
        createTaskChart();
        createComparisonChart();
      }

      // Logo mapping for proprietary LLMs - using local logos
      const modelLogos = {
        "GPT-4o": "llm_logos/Openai_logo.svg",
        GPT4o: "llm_logos/Openai_logo.svg",
        gpt4o: "llm_logos/Openai_logo.svg",
        OpenAI: "llm_logos/Openai_logo.svg",
        openai: "llm_logos/Openai_logo.svg",
        Gemini: "llm_logos/Google-gemini-icon.svg",
        gemini: "llm_logos/Google-gemini-icon.svg",
        Gemini2p5: "llm_logos/Google-gemini-icon.svg",
        gemini2p5: "llm_logos/Google-gemini-icon.svg",
        Claude: "https://avatars.githubusercontent.com/u/33663932?s=200&v=4",
        claude: "https://avatars.githubusercontent.com/u/33663932?s=200&v=4",
        Llama: "llm_logos/Meta_logo.svg",
        llama: "llm_logos/Meta_logo.svg",
        Llama3: "llm_logos/Meta_logo.svg",
        llama3: "llm_logos/Meta_logo.svg",
        Meta: "llm_logos/Meta_logo.svg",
        meta: "llm_logos/Meta_logo.svg",
        Mistral: "llm_logos/Mistral_AI_logo.svg",
        mistral: "llm_logos/Mistral_AI_logo.svg",
        Gemma: "llm_logos/Gemma_logo.svg",
        gemma: "llm_logos/Gemma_logo.svg",
        DeepSeek: "llm_logos/DeepSeek_logo.svg",
        deepseek: "llm_logos/DeepSeek_logo.svg",
      };

      function getModelLogo(modelId) {
        // Check for exact match first
        if (modelLogos[modelId]) return modelLogos[modelId];

        // Check for partial matches - order matters, most specific first
        const modelIdLower = modelId.toLowerCase();
        
        // Check for DeepSeek first (before other matches)
        if (modelIdLower.includes('deepseek')) return modelLogos['DeepSeek'];
        
        // Check for other models
        if (modelIdLower.includes('gpt') || modelIdLower.includes('openai')) return modelLogos['OpenAI'];
        if (modelIdLower.includes('gemini')) return modelLogos['Gemini'];
        if (modelIdLower.includes('gemma')) return modelLogos['Gemma'];
        if (modelIdLower.includes('claude')) return modelLogos['Claude'];
        if (modelIdLower.includes('llama') || modelIdLower.includes('meta')) return modelLogos['Llama'];
        if (modelIdLower.includes('mistral')) return modelLogos['Mistral'];
        
        return null;
      }

      async function loadImage(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = () => resolve(img);
          img.onerror = () => resolve(null); // Return null if image fails to load
          img.src = src;
        });
      }

      async function createPerformanceChart() {
        const ctx = document
          .getElementById("performanceChart")
          .getContext("2d");
        const filteredData = getFilteredData();
        const primaryMetric = document.getElementById("primaryMetric").value;

        // Group by model and calculate average performance
        const modelPerformance = {};
        filteredData.forEach((d) => {
          if (!modelPerformance[d.model_id]) {
            modelPerformance[d.model_id] = {
              scores: [],
              type: getModelType(d.model_id),
            };
          }
          const score = d.metrics_summary?.overall?.[primaryMetric];
          if (score !== undefined) {
            modelPerformance[d.model_id].scores.push(score);
          }
        });

        const models = Object.keys(modelPerformance);
        const avgScores = models.map((model) => {
          const scores = modelPerformance[model].scores;
          return scores.reduce((sum, score) => sum + score, 0) / scores.length;
        });

        const colors = models.map((model) =>
          modelPerformance[model].type === "llm"
            ? "rgba(102, 126, 234, 0.8)"
            : "rgba(252, 182, 159, 0.8)"
        );

        // Load logos for models that have them
        const modelImages = {};
        for (const model of models) {
          const logoUrl = getModelLogo(model);
          if (logoUrl) {
            modelImages[model] = await loadImage(logoUrl);
          }
        }

        if (charts.performance) {
          charts.performance.destroy();
        }

        charts.performance = new Chart(ctx, {
          type: "bar",
          data: {
            labels: models,
            datasets: [
              {
                label: primaryMetric.toUpperCase(),
                data: avgScores,
                backgroundColor: colors,
                borderColor: colors.map((color) => color.replace("0.8", "1")),
                borderWidth: 2,
                borderRadius: 8,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false,
              },
              // Custom plugin to draw logos
              beforeDraw: function (chart) {
                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const xAxis = chart.scales.x;

                models.forEach((model, index) => {
                  const image = modelImages[model];
                  if (image) {
                    const x = xAxis.getPixelForValue(index);
                    const logoSize = 24;

                    // Position logo above the bar
                    const datasetMeta = chart.getDatasetMeta(0);
                    const bar = datasetMeta.data[index];
                    const y = bar.y - logoSize - 10;

                    // Draw logo
                    ctx.save();
                    ctx.globalAlpha = 0.8;
                    ctx.drawImage(
                      image,
                      x - logoSize / 2,
                      y,
                      logoSize,
                      logoSize
                    );
                    ctx.restore();
                  }
                });
              },
            },
            scales: {
              y: {
                beginAtZero: primaryMetric === "mcc" ? false : true,
                min: primaryMetric === "mcc" ? -1 : 0,
                max: 1,
                ticks: {
                  color: '#64748b'
                },
                grid: {
                  color: 'rgba(148, 163, 184, 0.1)'
                }
              },
              x: {
                ticks: {
                  maxRotation: 45,
                  color: '#64748b'
                },
                grid: {
                  display: false
                }
              },
            },
            // Add clinical threshold line
            elements: {
              line: {
                borderColor: clinicalThresholds[primaryMetric] ? '#dc2626' : 'transparent',
                borderWidth: 2,
                borderDash: [5, 5]
              }
            },
          },
          plugins: [
            {
              id: "logoRenderer",
              beforeDraw: function (chart) {
                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const xAxis = chart.scales.x;

                models.forEach((model, index) => {
                  const image = modelImages[model];
                  if (image) {
                    const x = xAxis.getPixelForValue(index);
                    const logoSize = 24;

                    // Position logo above the bar
                    const datasetMeta = chart.getDatasetMeta(0);
                    const bar = datasetMeta.data[index];
                    const y = bar.y - logoSize - 10;

                    // Draw logo
                    ctx.save();
                    ctx.globalAlpha = 0.8;
                    ctx.drawImage(
                      image,
                      x - logoSize / 2,
                      y,
                      logoSize,
                      logoSize
                    );
                    ctx.restore();
                  }
                });
              },
            },
          ],
        });
      }

      function createTaskChart() {
        const ctx = document.getElementById("taskChart").getContext("2d");
        const filteredData = getFilteredData();
        const primaryMetric = document.getElementById("primaryMetric").value;

        // Group by task and calculate average performance
        const taskPerformance = {};
        filteredData.forEach((d) => {
          if (!taskPerformance[d.task_id]) {
            taskPerformance[d.task_id] = [];
          }
          const score = d.metrics_summary?.overall?.[primaryMetric];
          if (score !== undefined) {
            taskPerformance[d.task_id].push(score);
          }
        });

        const tasks = Object.keys(taskPerformance);
        const avgScores = tasks.map((task) => {
          const scores = taskPerformance[task];
          return scores.reduce((sum, score) => sum + score, 0) / scores.length;
        });

        if (charts.task) {
          charts.task.destroy();
        }

        charts.task = new Chart(ctx, {
          type: "doughnut",
          data: {
            labels: tasks.map(
              (task) => task.charAt(0).toUpperCase() + task.slice(1)
            ),
            datasets: [
              {
                data: avgScores,
                backgroundColor: [
                  "rgba(102, 126, 234, 0.8)",
                  "rgba(118, 75, 162, 0.8)",
                  "rgba(255, 99, 132, 0.8)",
                  "rgba(54, 162, 235, 0.8)",
                  "rgba(255, 205, 86, 0.8)",
                ],
                borderWidth: 3,
                borderColor: "#fff",
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: "bottom",
              },
            },
          },
        });
      }

      function createComparisonChart() {
        const ctx = document.getElementById("comparisonChart").getContext("2d");
        const filteredData = getFilteredData();
        const primaryMetric = document.getElementById("primaryMetric").value;

        // Separate LLMs and baselines
        const llmScores = [];
        const baselineScores = [];

        filteredData.forEach((d) => {
          const score = d.metrics_summary?.overall?.[primaryMetric];
          if (score !== undefined) {
            if (getModelType(d.model_id) === "llm") {
              llmScores.push(score);
            } else {
              baselineScores.push(score);
            }
          }
        });

        const llmAvg =
          llmScores.length > 0
            ? llmScores.reduce((sum, score) => sum + score, 0) /
              llmScores.length
            : 0;
        const baselineAvg =
          baselineScores.length > 0
            ? baselineScores.reduce((sum, score) => sum + score, 0) /
              baselineScores.length
            : 0;

        if (charts.comparison) {
          charts.comparison.destroy();
        }

        charts.comparison = new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["LLMs", "Baseline Models"],
            datasets: [
              {
                label: `Average ${primaryMetric.toUpperCase()}`,
                data: [llmAvg, baselineAvg],
                backgroundColor: [
                  "rgba(102, 126, 234, 0.8)",
                  "rgba(252, 182, 159, 0.8)",
                ],
                borderColor: [
                  "rgba(102, 126, 234, 1)",
                  "rgba(252, 182, 159, 1)",
                ],
                borderWidth: 2,
                borderRadius: 8,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false,
              },
            },
            scales: {
              y: {
                beginAtZero: primaryMetric === "mcc" ? false : true,
                min: primaryMetric === "mcc" ? -1 : 0,
                max: 1,
              },
            },
          },
        });
      }

      function updateTable() {
        const filteredData = getFilteredData();
        const tbody = document.getElementById("resultsTableBody");

        if (filteredData.length === 0) {
          tbody.innerHTML =
            '<tr><td colspan="8" class="no-data">No data matches the current filters</td></tr>';
          return;
        }

        tbody.innerHTML = "";

        // Sort by primary metric descending
        const primaryMetric = document.getElementById("primaryMetric").value;
        filteredData.sort((a, b) => {
          const aScore = a.metrics_summary?.overall?.[primaryMetric] || 0;
          const bScore = b.metrics_summary?.overall?.[primaryMetric] || 0;
          return bScore - aScore;
        });

        filteredData.forEach((d) => {
          const metrics = d.metrics_summary?.overall || {};
          const modelType = getModelType(d.model_id);

          // Safety check for required fields
          if (!d.model_id || !d.task_id || !d.dataset) {
            console.warn("Skipping entry with missing required fields:", d);
            return;
          }

          const row = document.createElement("tr");
          row.innerHTML = `
                    <td>${d.model_id}</td>
                    <td><span class="model-type-badge ${modelType}-badge">${modelType.toUpperCase()}</span></td>
                    <td>${
                      d.task_id.charAt(0).toUpperCase() + d.task_id.slice(1)
                    }</td>
                    <td>${d.dataset.toUpperCase()}</td>
                    <td><span class="metric-value ${getMetricClass(
                      metrics.auroc, 'auroc'
                    )}">${(metrics.auroc || 0).toFixed(3)}</span></td>
                    <td><span class="metric-value ${getMetricClass(
                      metrics.auprc, 'auprc'
                    )}">${(metrics.auprc || 0).toFixed(3)}</span></td>
                    <td><span class="metric-value ${getMetricClass(
                      metrics.mcc, 'mcc'
                    )}">${(metrics.mcc || 0).toFixed(3)}</span></td>
                    <td><span class="metric-value ${getMetricClass(
                      metrics.f1_score, 'f1_score'
                    )}">${(metrics.f1_score || 0).toFixed(3)}</span></td>
                `;
          tbody.appendChild(row);
        });
      }

      function getMetricClass(value, metricType = 'general') {
        // Use clinical thresholds for better medical interpretation
        if (metricType === 'auroc') {
          if (value >= clinicalThresholds.auroc) return "metric-high";
          if (value >= 0.7) return "metric-medium";
          return "metric-low";
        }
        if (metricType === 'auprc') {
          if (value >= clinicalThresholds.auprc) return "metric-high";
          if (value >= 0.5) return "metric-medium";
          return "metric-low";
        }
        if (metricType === 'mcc') {
          if (value >= clinicalThresholds.mcc) return "metric-high";
          if (value >= 0.3) return "metric-medium";
          return "metric-low";
        }
        if (metricType === 'f1_score') {
          if (value >= clinicalThresholds.f1_score) return "metric-high";
          if (value >= 0.5) return "metric-medium";
          return "metric-low";
        }
        
        // Default behavior for backward compatibility
        if (value >= 0.8) return "metric-high";
        if (value >= 0.6) return "metric-medium";
        if (value >= 0.0) return "metric-low";
        return "metric-low"; // For negative values (like MCC)
      }

      function setupEventListeners() {
        [
          "taskFilter",
          "datasetFilter",
          "modelTypeFilter",
          "primaryMetric",
        ].forEach((id) => {
          document.getElementById(id).addEventListener("change", async () => {
            updateSummaryStats();
            await createCharts();
            updateTable();
          });
        });
      }
    </script>
  </body>
</html>
