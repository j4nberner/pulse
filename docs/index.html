<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ICU Time-Series Prediction Benchmark</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: #ffffff;
        min-height: 100vh;
        color: #2c2c2c;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        background: #ffffff;
        border-radius: 20px;
        padding: 30px;
        margin-bottom: 30px;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        border: 1px solid #e8e8e8;
      }

      .header h1 {
        font-size: 2.5em;
        background: linear-gradient(135deg, #667eea, #764ba2);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 10px;
      }

      .header-content {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 20px;
        margin-bottom: 20px;
      }

      .pulse-logo {
        height: 60px;
        width: auto;
      }

      .gold-cup {
        color: #ffd700;
        font-size: 1.2em;
        margin-left: 8px;
        display: inline-block;
        animation: sparkle 2s ease-in-out infinite;
      }

      @keyframes sparkle {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      .header p {
        font-size: 1.2em;
        color: #5a5a5a;
        margin-bottom: 20px;
      }

      .controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 20px;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
      }

      .control-group label {
        font-weight: 600;
        color: #444;
        font-size: 0.9em;
      }

      select,
      input {
        padding: 10px 15px;
        border: 2px solid #e0e0e0;
        border-radius: 10px;
        background: white;
        font-size: 14px;
        transition: all 0.3s ease;
        min-width: 120px;
      }

      select:focus,
      input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      .dashboard {
        display: grid;
        gap: 25px;
        grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
      }

      .card {
        background: #fafafa;
        border-radius: 20px;
        padding: 25px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        border: 1px solid #e8e8e8;
      }

      .card:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
      }

      .card h3 {
        font-size: 1.4em;
        margin-bottom: 20px;
        color: #2c2c2c;
        text-align: center;
        padding-bottom: 10px;
        border-bottom: 2px solid #e8e8e8;
      }

      .chart-container {
        position: relative;
        height: 400px;
        margin-bottom: 20px;
      }

      .table-container {
        overflow-x: auto;
        margin-top: 20px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        background: #ffffff;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      }

      th,
      td {
        padding: 12px 15px;
        text-align: left;
        border-bottom: 1px solid #e8e8e8;
      }

      th {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        font-weight: 600;
        text-transform: uppercase;
        font-size: 0.85em;
        letter-spacing: 0.5px;
      }

      tr:hover {
        background-color: #f8f8f8;
      }

      .metric-value {
        font-weight: 600;
        padding: 4px 8px;
        border-radius: 6px;
        display: inline-block;
        min-width: 60px;
        text-align: center;
      }

      .metric-medium {
        /* background: linear-gradient(135deg, #4facfe, #0026fe); */
        color: rgb(73, 73, 73);
      }

      .metric-high {
        /* background: linear-gradient(135deg, #43e97b, #38f9d7); */
        color: rgb(73, 73, 73);
      }

      .metric-low {
        /* background: linear-gradient(135deg, #fa709a, #ffffff); */
        color: rgb(73, 73, 73);
      }

      .summary-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin-bottom: 25px;
      }

      .stat-card {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 20px;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
      }

      .stat-value {
        font-size: 2em;
        font-weight: bold;
        margin-bottom: 5px;
      }

      .stat-label {
        font-size: 0.9em;
        opacity: 0.9;
      }

      .model-type-badge {
        display: inline-block;
        padding: 4px 10px;
        border-radius: 15px;
        font-size: 0.8em;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .llm-badge {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
      }

      .baseline-badge {
        background: linear-gradient(135deg, #ffecd2, #fcb69f);
        color: #8b4513;
      }

      .loading {
        text-align: center;
        padding: 50px;
        font-size: 1.2em;
        color: #5a5a5a;
      }

      .no-data {
        text-align: center;
        padding: 40px;
        color: #777;
        font-style: italic;
      }

      /* Tab Styles */
      .tabs {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
        background: #f5f5f5;
        border-radius: 15px;
        padding: 5px;
        border: 1px solid #e8e8e8;
      }

      .tab-button {
        background: transparent;
        border: none;
        padding: 12px 24px;
        cursor: pointer;
        border-radius: 10px;
        font-weight: 600;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: #5a5a5a;
      }

      .tab-button.active {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
      }

      .tab-button:hover:not(.active) {
        background: rgba(102, 126, 234, 0.1);
        color: #667eea;
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      @media (max-width: 768px) {
        .dashboard {
          grid-template-columns: 1fr;
        }

        .controls {
          flex-direction: column;
          align-items: stretch;
        }

        .control-group {
          align-items: stretch;
        }

        .header-content {
          flex-direction: column;
          gap: 10px;
        }

        .header h1 {
          font-size: 2em;
          text-align: center;
        }

        .pulse-logo {
          height: 40px;
        }

        .tabs {
          flex-direction: column;
        }

        .tab-button {
          border-radius: 10px !important;
          margin-bottom: 5px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="header-content">
          <img src="pulse_logo.svg" alt="PULSE Logo" class="pulse-logo" />
          <h1>ICU Time-Series Prediction Benchmark</h1>
        </div>
        <p>
          Comprehensive comparison of LLMs and baseline models on ICU prediction
          tasks
        </p>

        <!-- Tab Navigation -->
        <div class="tabs">
          <button class="tab-button active" onclick="switchTab('overall')">Overall</button>
          <button class="tab-button" onclick="switchTab('aki')">AKI</button>
          <button class="tab-button" onclick="switchTab('mortality')">Mortality</button>
          <button class="tab-button" onclick="switchTab('sepsis')">Sepsis</button>
        </div>
      </div>

      <!-- Tab Contents -->
      <div id="overall-tab" class="tab-content active">
        <!-- Summary Stats -->
        <div class="summary-stats" id="overallSummaryStats">
          <div class="stat-card">
            <div class="stat-value" id="overallTotalModels">-</div>
            <div class="stat-label">Total Models</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="overallTotalTasks">-</div>
            <div class="stat-label">Tasks</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="overallBestModel">-</div>
            <div class="stat-label">Best Model</div>
          </div>
        </div>

        <!-- Filters -->
        <div class="header">
          <h2>Overall Performance Across All Tasks</h2>
          <div class="controls">
            <div class="control-group">
              <label>Model Type</label>
              <select id="overallModelTypeFilter">
                <option value="all">All Models</option>
                <option value="llm">LLMs Only</option>
                <option value="baseline">Baselines Only</option>
              </select>
            </div>
            <div class="control-group">
              <label>Primary Metric</label>
              <select id="overallPrimaryMetric">
                <option value="auroc">AUROC</option>
                <option value="auprc">AUPRC</option>
                <option value="normalized_auprc">Normalized AUPRC</option>
                <option value="mcc">MCC</option>
                <option value="specificity">Specificity</option>
                <option value="f1_score">F1 Score</option>
                <option value="accuracy">Accuracy</option>
                <option value="balanced_accuracy">Balanced Accuracy</option>
                <option value="precision">Precision</option>
                <option value="recall">Recall</option>
                <option value="kappa">Kappa</option>
                <option value="minpse">MinPSE</option>
                <option value="task_dataset_score" selected>PULSE Score</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Performance Chart -->
        <div class="card" style="margin-bottom: 25px;">
          <h3>Overall Model Performance Comparison</h3>
          <div class="chart-container">
            <canvas id="overallPerformanceChart"></canvas>
          </div>
        </div>

        <!-- Results Table (Full Width) -->
        <div class="card">
          <h3>Overall Detailed Results Table</h3>
          <div class="table-container">
            <table id="overallResultsTable">
              <thead>
                <tr>
                  <th>Model</th>
                  <th>Type</th>
                  <th>PULSE Score</th>
                  <th>AUROC</th>
                  <th>AUPRC</th>
                  <th>MCC</th>
                  <th>Norm AUPRC</th>
                  <th>Specificity</th>
                  <th>F1 Score</th>
                  <th>Accuracy</th>
                  <th>Bal Accuracy</th>
                  <th>Precision</th>
                  <th>Recall</th>
                  <th>Kappa</th>
                  <th>MinPSE</th>
                </tr>
              </thead>
              <tbody id="overallResultsTableBody">
                <tr>
                  <td colspan="15" class="loading">Loading overall results...</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <div id="aki-tab" class="tab-content">
        <!-- Summary Stats -->
        <div class="summary-stats" id="akiSummaryStats">
          <div class="stat-card">
            <div class="stat-value" id="akiTotalModels">-</div>
            <div class="stat-label">Total Models</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="akiTotalDatasets">-</div>
            <div class="stat-label">Datasets</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="akiBestModel">-</div>
            <div class="stat-label">Best Model</div>
          </div>
        </div>

        <!-- Filters -->
        <div class="header">
          <h2>Acute Kidney Injury (AKI) Prediction</h2>
          <div class="controls">
            <div class="control-group">
              <label>Dataset</label>
              <select id="akiDatasetFilter">
                <option value="all">All Datasets</option>
                <option value="hirid">HiRID</option>
                <option value="eicu">eICU</option>
                <option value="miiv">MIMIC-IV</option>
              </select>
            </div>
            <div class="control-group">
              <label>Model Type</label>
              <select id="akiModelTypeFilter">
                <option value="all">All Models</option>
                <option value="llm">LLMs Only</option>
                <option value="baseline">Baselines Only</option>
              </select>
            </div>
            <div class="control-group">
              <label>Primary Metric</label>
              <select id="akiPrimaryMetric">
                <option value="auroc">AUROC</option>
                <option value="auprc">AUPRC</option>
                <option value="normalized_auprc">Normalized AUPRC</option>
                <option value="mcc">MCC</option>
                <option value="specificity">Specificity</option>
                <option value="f1_score">F1 Score</option>
                <option value="accuracy">Accuracy</option>
                <option value="balanced_accuracy">Balanced Accuracy</option>
                <option value="precision">Precision</option>
                <option value="recall">Recall</option>
                <option value="kappa">Kappa</option>
                <option value="minpse">MinPSE</option>
                <option value="task_dataset_score" selected>PULSE Score</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Performance Chart -->
        <div class="card" style="margin-bottom: 25px;">
          <h3>AKI Model Performance Comparison</h3>
          <div class="chart-container">
            <canvas id="akiPerformanceChart"></canvas>
          </div>
        </div>

        <!-- Results Table (Full Width) -->
        <div class="card">
          <h3>AKI Detailed Results Table</h3>
          <div class="table-container">
            <table id="akiResultsTable">
              <thead>
                <tr>
                  <th>Model</th>
                  <th>Type</th>
                  <th>Dataset</th>
                  <th>AUROC</th>
                  <th>AUPRC</th>
                  <th>Norm AUPRC</th>
                  <th>MCC</th>
                  <th>Specificity</th>
                  <th>F1 Score</th>
                  <th>Accuracy</th>
                  <th>Bal Accuracy</th>
                  <th>Precision</th>
                  <th>Recall</th>
                  <th>Kappa</th>
                  <th>MinPSE</th>
                  <th>PULSE Score</th>
                </tr>
              </thead>
              <tbody id="akiResultsTableBody">
                <tr>
                  <td colspan="16" class="loading">Loading AKI results...</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <div id="mortality-tab" class="tab-content">
        <!-- Summary Stats -->
        <div class="summary-stats" id="mortalitySummaryStats">
          <div class="stat-card">
            <div class="stat-value" id="mortalityTotalModels">-</div>
            <div class="stat-label">Total Models</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="mortalityTotalDatasets">-</div>
            <div class="stat-label">Datasets</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="mortalityBestModel">-</div>
            <div class="stat-label">Best Model</div>
          </div>
        </div>

        <!-- Filters -->
        <div class="header">
          <h2>Mortality Prediction</h2>
          <div class="controls">
            <div class="control-group">
              <label>Dataset</label>
              <select id="mortalityDatasetFilter">
                <option value="all">All Datasets</option>
                <option value="hirid">HiRID</option>
                <option value="eicu">eICU</option>
                <option value="miiv">MIMIC-IV</option>
              </select>
            </div>
            <div class="control-group">
              <label>Model Type</label>
              <select id="mortalityModelTypeFilter">
                <option value="all">All Models</option>
                <option value="llm">LLMs Only</option>
                <option value="baseline">Baselines Only</option>
              </select>
            </div>
            <div class="control-group">
              <label>Primary Metric</label>
              <select id="mortalityPrimaryMetric">
                <option value="auroc">AUROC</option>
                <option value="auprc">AUPRC</option>
                <option value="normalized_auprc">Normalized AUPRC</option>
                <option value="mcc">MCC</option>
                <option value="specificity">Specificity</option>
                <option value="f1_score">F1 Score</option>
                <option value="accuracy">Accuracy</option>
                <option value="balanced_accuracy">Balanced Accuracy</option>
                <option value="precision">Precision</option>
                <option value="recall">Recall</option>
                <option value="kappa">Kappa</option>
                <option value="minpse">MinPSE</option>
                <option value="task_dataset_score" selected>PULSE Score</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Performance Chart -->
        <div class="card" style="margin-bottom: 25px;">
          <h3>Mortality Model Performance Comparison</h3>
          <div class="chart-container">
            <canvas id="mortalityPerformanceChart"></canvas>
          </div>
        </div>

        <!-- Results Table (Full Width) -->
        <div class="card">
          <h3>Mortality Detailed Results Table</h3>
          <div class="table-container">
            <table id="mortalityResultsTable">
              <thead>
                <tr>
                  <th>Model</th>
                  <th>Type</th>
                  <th>Dataset</th>
                  <th>AUROC</th>
                  <th>AUPRC</th>
                  <th>Norm AUPRC</th>
                  <th>MCC</th>
                  <th>Specificity</th>
                  <th>F1 Score</th>
                  <th>Accuracy</th>
                  <th>Bal Accuracy</th>
                  <th>Precision</th>
                  <th>Recall</th>
                  <th>Kappa</th>
                  <th>MinPSE</th>
                  <th>PULSE Score</th>
                </tr>
              </thead>
              <tbody id="mortalityResultsTableBody">
                <tr>
                  <td colspan="16" class="loading">Loading mortality results...</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <div id="sepsis-tab" class="tab-content">
        <!-- Summary Stats -->
        <div class="summary-stats" id="sepsisSummaryStats">
          <div class="stat-card">
            <div class="stat-value" id="sepsisTotalModels">-</div>
            <div class="stat-label">Total Models</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="sepsisTotalDatasets">-</div>
            <div class="stat-label">Datasets</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="sepsisBestModel">-</div>
            <div class="stat-label">Best Model</div>
          </div>
        </div>

        <!-- Filters -->
        <div class="header">
          <h2>Sepsis Prediction</h2>
          <div class="controls">
            <div class="control-group">
              <label>Dataset</label>
              <select id="sepsisDatasetFilter">
                <option value="all">All Datasets</option>
                <option value="hirid">HiRID</option>
                <option value="eicu">eICU</option>
                <option value="miiv">MIMIC-IV</option>
              </select>
            </div>
            <div class="control-group">
              <label>Model Type</label>
              <select id="sepsisModelTypeFilter">
                <option value="all">All Models</option>
                <option value="llm">LLMs Only</option>
                <option value="baseline">Baselines Only</option>
              </select>
            </div>
            <div class="control-group">
              <label>Primary Metric</label>
              <select id="sepsisPrimaryMetric">
                <option value="auroc">AUROC</option>
                <option value="auprc">AUPRC</option>
                <option value="normalized_auprc">Normalized AUPRC</option>
                <option value="mcc">MCC</option>
                <option value="specificity">Specificity</option>
                <option value="f1_score">F1 Score</option>
                <option value="accuracy">Accuracy</option>
                <option value="balanced_accuracy">Balanced Accuracy</option>
                <option value="precision">Precision</option>
                <option value="recall">Recall</option>
                <option value="kappa">Kappa</option>
                <option value="minpse">MinPSE</option>
                <option value="task_dataset_score" selected>PULSE Score</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Performance Chart -->
        <div class="card" style="margin-bottom: 25px;">
          <h3>Sepsis Model Performance Comparison</h3>
          <div class="chart-container">
            <canvas id="sepsisPerformanceChart"></canvas>
          </div>
        </div>

        <!-- Results Table (Full Width) -->
        <div class="card">
          <h3>Sepsis Detailed Results Table</h3>
          <div class="table-container">
            <table id="sepsisResultsTable">
              <thead>
                <tr>
                  <th>Model</th>
                  <th>Type</th>
                  <th>Dataset</th>
                  <th>AUROC</th>
                  <th>AUPRC</th>
                  <th>Norm AUPRC</th>
                  <th>MCC</th>
                  <th>Specificity</th>
                  <th>F1 Score</th>
                  <th>Accuracy</th>
                  <th>Bal Accuracy</th>
                  <th>Precision</th>
                  <th>Recall</th>
                  <th>Kappa</th>
                  <th>MinPSE</th>
                  <th>PULSE Score</th>
                </tr>
              </thead>
              <tbody id="sepsisResultsTableBody">
                <tr>
                  <td colspan="16" class="loading">Loading sepsis results...</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      }
    </div>

    <script>
      console.log("Script loaded successfully");
      let allData = [];
      let charts = {};
      let currentTask = 'overall';

      // Baseline model identifiers
      const baselineModels = [
        "CNN",
        "LSTM", 
        "GRU",
        "XGBoost",
        "LightGBM",
        "RandomForest",
        "InceptionTime",
      ];

      function isBaselineModel(modelId) {
        return baselineModels.some((baseline) =>
          modelId.toLowerCase().includes(baseline.toLowerCase())
        );
      }

      function getModelType(modelId) {
        return isBaselineModel(modelId) ? "baseline" : "llm";
      }

      // Switch between tabs
      function switchTab(task) {
        // Hide all tab contents
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        
        // Remove active class from all tab buttons
        document.querySelectorAll('.tab-button').forEach(button => {
          button.classList.remove('active');
        });
        
        // Show selected tab content
        document.getElementById(`${task}-tab`).classList.add('active');
        
        // Add active class to selected tab button
        event.target.classList.add('active');
        
        currentTask = task;
        
        // Update the current tab's content
        updateCurrentTab();
      }

      // Load all JSON files from the jsons folder
      async function loadAllResults() {
        console.log("Loading all result files...");
        
        // List of all model files based on the directory listing
        const modelFiles = [
          "claudesonnet4_results.json",
          "CNN_results.json", 
          "deepseekr1llama8b_results.json",
          "gemini2p5flash_results.json",
          "gemini2p5pro_results.json",
          "gemma3_results.json",
          "gpt4o_results.json",
          "GRU_results.json",
          "InceptionTime_results.json",
          "LightGBM_results.json",
          "llama3p18b_results.json",
          "LSTM_results.json",
          "medgemma_results.json",
          "mistral7b_results.json",
          "o3_results.json",
          "RandomForest_results.json",
          "XGBoost_results.json"
        ];

        allData = [];
        
        for (const fileName of modelFiles) {
          try {
            console.log(`Loading ${fileName}...`);
            const response = await fetch(`jsons/${fileName}`);
            
            if (!response.ok) {
              console.warn(`Failed to load ${fileName}: ${response.status}`);
              continue;
            }
            
            const data = await response.json();
            console.log(`Loaded ${fileName}:`, data);
            
            // Extract results array
            let results = [];
            if (Array.isArray(data)) {
              results = data;
            } else if (data.results && Array.isArray(data.results)) {
              results = data.results;
            } else {
              console.warn(`Invalid format in ${fileName}`);
              continue;
            }
            
            // Add each result to allData
            results.forEach(result => {
              if (result.metrics_summary && result.metrics_summary.overall) {
                allData.push({
                  model_id: result.model_id,
                  task_id: result.task_id, 
                  dataset: result.dataset,
                  metrics: result.metrics_summary.overall,
                  fileName: fileName
                });
              }
            });
            
          } catch (error) {
            console.error(`Error loading ${fileName}:`, error);
          }
        }
        
        console.log("All data loaded:", allData);
        console.log("Total entries:", allData.length);
        
        // Initialize the dashboard
        initializeDashboard();
      }

      // Load data when page loads
      window.addEventListener("load", () => {
        console.log("Window load event fired");
        loadAllResults();
      });

      function initializeDashboard() {
        console.log("Initializing dashboard with data:", allData);
        updateCurrentTab();
        setupEventListeners();
      }

      function updateCurrentTab() {
        updateSummaryStats(currentTask);
        createPerformanceChart(currentTask);
        updateTable(currentTask);
      }

      function getFilteredData(task) {
        if (task === 'overall') {
          return getOverallFilteredData();
        }
        
        const datasetFilter = document.getElementById(`${task}DatasetFilter`).value;
        const modelTypeFilter = document.getElementById(`${task}ModelTypeFilter`).value;

        return allData.filter((d) => {
          // Filter by task
          if (d.task_id !== task) return false;
          
          // Filter by dataset
          const datasetMatch = datasetFilter === "all" || d.dataset === datasetFilter;
          
          // Filter by model type
          const modelType = getModelType(d.model_id);
          const modelTypeMatch = modelTypeFilter === "all" || modelType === modelTypeFilter;

          return datasetMatch && modelTypeMatch;
        });
      }

      function getOverallFilteredData() {
        const modelTypeFilter = document.getElementById('overallModelTypeFilter').value;
        
        return allData.filter((d) => {
          // Filter by model type
          const modelType = getModelType(d.model_id);
          const modelTypeMatch = modelTypeFilter === "all" || modelType === modelTypeFilter;
          return modelTypeMatch;
        });
      }

      function updateSummaryStats(task) {
        if (task === 'overall') {
          updateOverallSummaryStats();
          return;
        }
        
        const filteredData = getFilteredData(task);
        const models = [...new Set(filteredData.map((d) => d.model_id))];
        const datasets = [...new Set(filteredData.map((d) => d.dataset))];

        const primaryMetric = document.getElementById(`${task}PrimaryMetric`).value;

        // Find best model by average score
        const modelAverages = {};
        filteredData.forEach((d) => {
          const score = d.metrics[primaryMetric];
          if (score !== undefined && score !== null) {
            if (!modelAverages[d.model_id]) {
              modelAverages[d.model_id] = { scores: [], entries: [] };
            }
            modelAverages[d.model_id].scores.push(score);
            modelAverages[d.model_id].entries.push(d);
          }
        });

        let bestModelByAverage = null;
        let bestAverageScore = -Infinity;
        Object.keys(modelAverages).forEach((modelId) => {
          const scores = modelAverages[modelId].scores;
          const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
          if (avgScore > bestAverageScore) {
            bestAverageScore = avgScore;
            bestModelByAverage = modelId;
          }
        });

        document.getElementById(`${task}TotalModels`).textContent = models.length;
        document.getElementById(`${task}TotalDatasets`).textContent = datasets.length;

        const bestModelElement = document.getElementById(`${task}BestModel`);
        if (bestModelByAverage) {
          bestModelElement.innerHTML = `${bestModelByAverage} <span class="gold-cup">🏆</span>`;
        } else {
          bestModelElement.textContent = "-";
        }
      }

      function updateOverallSummaryStats() {
        const filteredData = getOverallFilteredData();
        const models = [...new Set(filteredData.map((d) => d.model_id))];
        const tasks = [...new Set(filteredData.map((d) => d.task_id))];
        
        const primaryMetric = document.getElementById('overallPrimaryMetric').value;
        
        // Calculate averages for each model across all tasks and datasets
        const modelAverages = {};
        filteredData.forEach((d) => {
          const score = d.metrics[primaryMetric];
          if (score !== undefined && score !== null) {
            if (!modelAverages[d.model_id]) {
              modelAverages[d.model_id] = { scores: [] };
            }
            modelAverages[d.model_id].scores.push(score);
          }
        });

        let bestModelByAverage = null;
        let bestAverageScore = -Infinity;
        Object.keys(modelAverages).forEach((modelId) => {
          const scores = modelAverages[modelId].scores;
          const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
          if (avgScore > bestAverageScore) {
            bestAverageScore = avgScore;
            bestModelByAverage = modelId;
          }
        });

        document.getElementById('overallTotalModels').textContent = models.length;
        document.getElementById('overallTotalTasks').textContent = tasks.length;

        const bestModelElement = document.getElementById('overallBestModel');
        if (bestModelByAverage) {
          bestModelElement.innerHTML = `${bestModelByAverage} <span class="gold-cup">🏆</span>`;
        } else {
          bestModelElement.textContent = "-";
        }
      }

      // Logo mapping for proprietary LLMs
      const modelLogos = {
        "GPT-4o": "llm_logos/Openai_logo.svg",
        GPT4o: "llm_logos/Openai_logo.svg",
        gpt4o: "llm_logos/Openai_logo.svg",
        o3: "llm_logos/Openai_logo.svg",
        O3: "llm_logos/Openai_logo.svg",
        OpenAI: "llm_logos/Openai_logo.svg",
        openai: "llm_logos/Openai_logo.svg",
        Claude: "llm_logos/Claude_logo.svg",
        claude: "llm_logos/Claude_logo.svg",
        claudesonnet4: "llm_logos/Claude_logo.svg",
        "claude-sonnet": "llm_logos/Claude_logo.svg",
        Gemini: "llm_logos/Google-gemini-icon.svg",
        gemini: "llm_logos/Google-gemini-icon.svg", 
        Gemini2p5: "llm_logos/Google-gemini-icon.svg",
        gemini2p5: "llm_logos/Google-gemini-icon.svg",
        Llama: "llm_logos/Meta_logo.svg",
        llama: "llm_logos/Meta_logo.svg",
        Llama3: "llm_logos/Meta_logo.svg", 
        llama3: "llm_logos/Meta_logo.svg",
        Meta: "llm_logos/Meta_logo.svg",
        meta: "llm_logos/Meta_logo.svg",
        Mistral: "llm_logos/Mistral_AI_logo.svg",
        mistral: "llm_logos/Mistral_AI_logo.svg",
        Gemma: "llm_logos/Gemma_logo.svg",
        gemma: "llm_logos/Gemma_logo.svg",
        DeepSeek: "llm_logos/DeepSeek_logo.svg",
        deepseek: "llm_logos/DeepSeek_logo.svg",
      };

      function getModelLogo(modelId) {
        if (modelLogos[modelId]) return modelLogos[modelId];

        const modelIdLower = modelId.toLowerCase();
        if (modelIdLower.includes("o3")) return modelLogos["o3"];
        if (modelIdLower.includes("deepseek")) return modelLogos["DeepSeek"];
        if (modelIdLower.includes("gpt") || modelIdLower.includes("openai")) return modelLogos["OpenAI"];
        if (modelIdLower.includes("claude")) return modelLogos["Claude"];
        if (modelIdLower.includes("gemini")) return modelLogos["Gemini"];
        if (modelIdLower.includes("gemma")) return modelLogos["Gemma"];
        if (modelIdLower.includes("llama") || modelIdLower.includes("meta")) return modelLogos["Llama"];
        if (modelIdLower.includes("mistral")) return modelLogos["Mistral"];

        return null;
      }

      async function loadImage(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = () => resolve(img);
          img.onerror = () => resolve(null);
          img.src = src;
        });
      }

      async function createPerformanceChart(task) {
        if (task === 'overall') {
          await createOverallPerformanceChart();
          return;
        }
        
        const ctx = document.getElementById(`${task}PerformanceChart`).getContext("2d");
        const filteredData = getFilteredData(task);
        const primaryMetric = document.getElementById(`${task}PrimaryMetric`).value;

        // Group by model and calculate average performance
        const modelPerformance = {};
        filteredData.forEach((d) => {
          if (!modelPerformance[d.model_id]) {
            modelPerformance[d.model_id] = {
              scores: [],
              type: getModelType(d.model_id),
            };
          }
          const score = d.metrics[primaryMetric];
          if (score !== undefined) {
            modelPerformance[d.model_id].scores.push(score);
          }
        });

        const models = Object.keys(modelPerformance);
        const avgScores = models.map((model) => {
          const scores = modelPerformance[model].scores;
          return scores.reduce((sum, score) => sum + score, 0) / scores.length;
        });

        // Create array of model data for sorting
        const modelData = models.map((model, index) => ({
          model: model,
          score: avgScores[index],
          type: modelPerformance[model].type
        }));

        // Sort by score descending
        modelData.sort((a, b) => b.score - a.score);

        // Extract sorted arrays
        const sortedModels = modelData.map(d => d.model);
        const sortedScores = modelData.map(d => d.score);
        const sortedColors = modelData.map(d => 
          d.type === "llm" ? "rgba(102, 126, 234, 0.8)" : "rgba(252, 182, 159, 0.8)"
        );

        // Load logos for models that have them
        const modelImages = {};
        for (const model of sortedModels) {
          const logoUrl = getModelLogo(model);
          if (logoUrl) {
            modelImages[model] = await loadImage(logoUrl);
          }
        }

        if (charts[`${task}Performance`]) {
          charts[`${task}Performance`].destroy();
        }

        charts[`${task}Performance`] = new Chart(ctx, {
          type: "bar",
          data: {
            labels: sortedModels,
            datasets: [
              {
                label: primaryMetric.toUpperCase(),
                data: sortedScores,
                backgroundColor: sortedColors,
                borderColor: sortedColors.map((color) => color.replace("0.8", "1")),
                borderWidth: 2,
                borderRadius: 8,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false,
              },
            },
            scales: {
              y: {
                beginAtZero: primaryMetric === "mcc" ? false : true,
                min: primaryMetric === "mcc" ? -1 : 0,
                max: primaryMetric === "task_dataset_score" ? 100 : 1,
              },
              x: {
                ticks: {
                  maxRotation: 45,
                },
              },
            },
          },
          plugins: [
            {
              id: "logoRenderer",
              beforeDraw: function (chart) {
                const ctx = chart.ctx;
                const xAxis = chart.scales.x;

                sortedModels.forEach((model, index) => {
                  const image = modelImages[model];
                  if (image) {
                    const x = xAxis.getPixelForValue(index);
                    const logoSize = 24;
                    const datasetMeta = chart.getDatasetMeta(0);
                    const bar = datasetMeta.data[index];
                    const y = bar.y - logoSize - 10;

                    ctx.save();
                    ctx.globalAlpha = 0.8;
                    ctx.drawImage(image, x - logoSize / 2, y, logoSize, logoSize);
                    ctx.restore();
                  }
                });
              },
            },
          ],
        });
      }

      async function createOverallPerformanceChart() {
        const ctx = document.getElementById('overallPerformanceChart').getContext("2d");
        const filteredData = getOverallFilteredData();
        const primaryMetric = document.getElementById('overallPrimaryMetric').value;

        // Group by model and calculate average performance across all tasks and datasets
        const modelPerformance = {};
        filteredData.forEach((d) => {
          if (!modelPerformance[d.model_id]) {
            modelPerformance[d.model_id] = {
              scores: [],
              type: getModelType(d.model_id),
            };
          }
          const score = d.metrics[primaryMetric];
          if (score !== undefined) {
            modelPerformance[d.model_id].scores.push(score);
          }
        });

        const models = Object.keys(modelPerformance);
        const avgScores = models.map((model) => {
          const scores = modelPerformance[model].scores;
          return scores.reduce((sum, score) => sum + score, 0) / scores.length;
        });

        // Create array of model data for sorting
        const modelData = models.map((model, index) => ({
          model: model,
          score: avgScores[index],
          type: modelPerformance[model].type
        }));

        // Sort by score descending
        modelData.sort((a, b) => b.score - a.score);

        // Extract sorted arrays
        const sortedModels = modelData.map(d => d.model);
        const sortedScores = modelData.map(d => d.score);
        const sortedColors = modelData.map(d => 
          d.type === "llm" ? "rgba(102, 126, 234, 0.8)" : "rgba(252, 182, 159, 0.8)"
        );

        // Load logos for models that have them
        const modelImages = {};
        for (const model of sortedModels) {
          const logoUrl = getModelLogo(model);
          if (logoUrl) {
            modelImages[model] = await loadImage(logoUrl);
          }
        }

        if (charts['overallPerformance']) {
          charts['overallPerformance'].destroy();
        }

        charts['overallPerformance'] = new Chart(ctx, {
          type: "bar",
          data: {
            labels: sortedModels,
            datasets: [
              {
                label: primaryMetric.toUpperCase(),
                data: sortedScores,
                backgroundColor: sortedColors,
                borderColor: sortedColors.map((color) => color.replace("0.8", "1")),
                borderWidth: 2,
                borderRadius: 8,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false,
              },
            },
            scales: {
              y: {
                beginAtZero: primaryMetric === "mcc" ? false : true,
                min: primaryMetric === "mcc" ? -1 : 0,
                max: primaryMetric === "task_dataset_score" ? 100 : 1,
              },
              x: {
                ticks: {
                  maxRotation: 45,
                },
              },
            },
          },
          plugins: [
            {
              id: "logoRenderer",
              beforeDraw: function (chart) {
                const ctx = chart.ctx;
                const xAxis = chart.scales.x;

                sortedModels.forEach((model, index) => {
                  const image = modelImages[model];
                  if (image) {
                    const x = xAxis.getPixelForValue(index);
                    const logoSize = 24;
                    const datasetMeta = chart.getDatasetMeta(0);
                    const bar = datasetMeta.data[index];
                    const y = bar.y - logoSize - 10;

                    ctx.save();
                    ctx.globalAlpha = 0.8;
                    ctx.drawImage(image, x - logoSize / 2, y, logoSize, logoSize);
                    ctx.restore();
                  }
                });
              },
            },
          ],
        });
      }

      function updateTable(task) {
        if (task === 'overall') {
          updateOverallTable();
          return;
        }
        
        const filteredData = getFilteredData(task);
        const tbody = document.getElementById(`${task}ResultsTableBody`);

        if (filteredData.length === 0) {
          tbody.innerHTML = `<tr><td colspan="16" class="no-data">No data matches the current filters</td></tr>`;
          return;
        }

        tbody.innerHTML = "";

        // Sort by primary metric descending
        const primaryMetric = document.getElementById(`${task}PrimaryMetric`).value;
        filteredData.sort((a, b) => {
          const aScore = a.metrics[primaryMetric] || 0;
          const bScore = b.metrics[primaryMetric] || 0;
          return bScore - aScore;
        });

        filteredData.forEach((d) => {
          const metrics = d.metrics;
          const modelType = getModelType(d.model_id);

          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${d.model_id}</td>
            <td><span class="model-type-badge ${modelType}-badge">${modelType.toUpperCase()}</span></td>
            <td>${d.dataset.toUpperCase()}</td>
            <td><span class="metric-value ${getMetricClass(metrics.auroc)}">${(metrics.auroc || 0).toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(metrics.auprc)}">${(metrics.auprc || 0).toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(metrics.normalized_auprc)}">${(metrics.normalized_auprc || 0).toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(metrics.mcc)}">${(metrics.mcc || 0).toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(metrics.specificity)}">${(metrics.specificity || 0).toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(metrics.f1_score)}">${(metrics.f1_score || 0).toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(metrics.accuracy)}">${(metrics.accuracy || 0).toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(metrics.balanced_accuracy)}">${(metrics.balanced_accuracy || 0).toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(metrics.precision)}">${(metrics.precision || 0).toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(metrics.recall)}">${(metrics.recall || 0).toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(metrics.kappa)}">${(metrics.kappa || 0).toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(metrics.minpse)}">${(metrics.minpse || 0).toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(metrics.task_dataset_score, true)}">${(metrics.task_dataset_score || 0).toFixed(1)}</span></td>
          `;
          tbody.appendChild(row);
        });
      }

      function updateOverallTable() {
        const filteredData = getOverallFilteredData();
        const tbody = document.getElementById('overallResultsTableBody');

        if (filteredData.length === 0) {
          tbody.innerHTML = `<tr><td colspan="15" class="no-data">No data matches the current filters</td></tr>`;
          return;
        }

        // Calculate averages for each model across all tasks and datasets
        const modelAverages = {};
        filteredData.forEach((d) => {
          if (!modelAverages[d.model_id]) {
            modelAverages[d.model_id] = {
              auroc: [],
              auprc: [],
              normalized_auprc: [],
              mcc: [],
              specificity: [],
              f1_score: [],
              accuracy: [],
              balanced_accuracy: [],
              precision: [],
              recall: [],
              kappa: [],
              minpse: [],
              task_dataset_score: [],
              type: getModelType(d.model_id)
            };
          }
          
          if (d.metrics.auroc !== undefined) modelAverages[d.model_id].auroc.push(d.metrics.auroc);
          if (d.metrics.auprc !== undefined) modelAverages[d.model_id].auprc.push(d.metrics.auprc);
          if (d.metrics.normalized_auprc !== undefined) modelAverages[d.model_id].normalized_auprc.push(d.metrics.normalized_auprc);
          if (d.metrics.mcc !== undefined) modelAverages[d.model_id].mcc.push(d.metrics.mcc);
          if (d.metrics.specificity !== undefined) modelAverages[d.model_id].specificity.push(d.metrics.specificity);
          if (d.metrics.f1_score !== undefined) modelAverages[d.model_id].f1_score.push(d.metrics.f1_score);
          if (d.metrics.accuracy !== undefined) modelAverages[d.model_id].accuracy.push(d.metrics.accuracy);
          if (d.metrics.balanced_accuracy !== undefined) modelAverages[d.model_id].balanced_accuracy.push(d.metrics.balanced_accuracy);
          if (d.metrics.precision !== undefined) modelAverages[d.model_id].precision.push(d.metrics.precision);
          if (d.metrics.recall !== undefined) modelAverages[d.model_id].recall.push(d.metrics.recall);
          if (d.metrics.kappa !== undefined) modelAverages[d.model_id].kappa.push(d.metrics.kappa);
          if (d.metrics.minpse !== undefined) modelAverages[d.model_id].minpse.push(d.metrics.minpse);
          if (d.metrics.task_dataset_score !== undefined) modelAverages[d.model_id].task_dataset_score.push(d.metrics.task_dataset_score);
        });

        // Calculate averages and create table rows
        const models = Object.keys(modelAverages);
        const primaryMetric = document.getElementById('overallPrimaryMetric').value;
        
        const modelResults = models.map(modelId => {
          const data = modelAverages[modelId];
          const avgAuroc = data.auroc.length > 0 ? data.auroc.reduce((sum, val) => sum + val, 0) / data.auroc.length : 0;
          const avgAuprc = data.auprc.length > 0 ? data.auprc.reduce((sum, val) => sum + val, 0) / data.auprc.length : 0;
          const avgNormAuprc = data.normalized_auprc.length > 0 ? data.normalized_auprc.reduce((sum, val) => sum + val, 0) / data.normalized_auprc.length : 0;
          const avgMcc = data.mcc.length > 0 ? data.mcc.reduce((sum, val) => sum + val, 0) / data.mcc.length : 0;
          const avgSpecificity = data.specificity.length > 0 ? data.specificity.reduce((sum, val) => sum + val, 0) / data.specificity.length : 0;
          const avgF1 = data.f1_score.length > 0 ? data.f1_score.reduce((sum, val) => sum + val, 0) / data.f1_score.length : 0;
          const avgAccuracy = data.accuracy.length > 0 ? data.accuracy.reduce((sum, val) => sum + val, 0) / data.accuracy.length : 0;
          const avgBalAccuracy = data.balanced_accuracy.length > 0 ? data.balanced_accuracy.reduce((sum, val) => sum + val, 0) / data.balanced_accuracy.length : 0;
          const avgPrecision = data.precision.length > 0 ? data.precision.reduce((sum, val) => sum + val, 0) / data.precision.length : 0;
          const avgRecall = data.recall.length > 0 ? data.recall.reduce((sum, val) => sum + val, 0) / data.recall.length : 0;
          const avgKappa = data.kappa.length > 0 ? data.kappa.reduce((sum, val) => sum + val, 0) / data.kappa.length : 0;
          const avgMinpse = data.minpse.length > 0 ? data.minpse.reduce((sum, val) => sum + val, 0) / data.minpse.length : 0;
          const avgPulse = data.task_dataset_score.length > 0 ? data.task_dataset_score.reduce((sum, val) => sum + val, 0) / data.task_dataset_score.length : 0;
          
          return {
            model_id: modelId,
            type: data.type,
            avgAuroc,
            avgAuprc,
            avgNormAuprc,
            avgMcc,
            avgSpecificity,
            avgF1,
            avgAccuracy,
            avgBalAccuracy,
            avgPrecision,
            avgRecall,
            avgKappa,
            avgMinpse,
            avgPulse,
            primaryScore: primaryMetric === 'auroc' ? avgAuroc : 
                         primaryMetric === 'auprc' ? avgAuprc :
                         primaryMetric === 'normalized_auprc' ? avgNormAuprc :
                         primaryMetric === 'mcc' ? avgMcc :
                         primaryMetric === 'specificity' ? avgSpecificity :
                         primaryMetric === 'f1_score' ? avgF1 :
                         primaryMetric === 'accuracy' ? avgAccuracy :
                         primaryMetric === 'balanced_accuracy' ? avgBalAccuracy :
                         primaryMetric === 'precision' ? avgPrecision :
                         primaryMetric === 'recall' ? avgRecall :
                         primaryMetric === 'kappa' ? avgKappa :
                         primaryMetric === 'minpse' ? avgMinpse : avgPulse
          };
        });

        // Sort by primary metric descending
        modelResults.sort((a, b) => b.primaryScore - a.primaryScore);

        tbody.innerHTML = "";

        modelResults.forEach((result) => {
          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${result.model_id}</td>
            <td><span class="model-type-badge ${result.type}-badge">${result.type.toUpperCase()}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgPulse, true)}">${result.avgPulse.toFixed(1)}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgAuroc)}">${result.avgAuroc.toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgAuprc)}">${result.avgAuprc.toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgMcc)}">${result.avgMcc.toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgNormAuprc)}">${result.avgNormAuprc.toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgSpecificity)}">${result.avgSpecificity.toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgF1)}">${result.avgF1.toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgAccuracy)}">${result.avgAccuracy.toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgBalAccuracy)}">${result.avgBalAccuracy.toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgPrecision)}">${result.avgPrecision.toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgRecall)}">${result.avgRecall.toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgKappa)}">${result.avgKappa.toFixed(3)}</span></td>
            <td><span class="metric-value ${getMetricClass(result.avgMinpse)}">${result.avgMinpse.toFixed(3)}</span></td>
          `;
          tbody.appendChild(row);
        });
      }

      function getMetricClass(value, isPulseScore = false) {
        if (isPulseScore) {
          if (value >= 70) return "metric-high";
          if (value >= 50) return "metric-medium";
          return "metric-low";
        } else {
          if (value >= 0.8) return "metric-high";
          if (value >= 0.6) return "metric-medium";
          return "metric-low";
        }
      }

      function setupEventListeners() {
        const tasks = ['aki', 'mortality', 'sepsis'];
        
        tasks.forEach(task => {
          [`${task}DatasetFilter`, `${task}ModelTypeFilter`, `${task}PrimaryMetric`].forEach((id) => {
            document.getElementById(id).addEventListener("change", async () => {
              if (currentTask === task) {
                updateCurrentTab();
              }
            });
          });
        });

        // Add event listeners for overall tab
        ['overallModelTypeFilter', 'overallPrimaryMetric'].forEach((id) => {
          document.getElementById(id).addEventListener("change", async () => {
            if (currentTask === 'overall') {
              updateCurrentTab();
            }
          });
        });
      }
    </script>
  </body>
</html>
