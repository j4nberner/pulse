<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ICU Time-Series Prediction Benchmark</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        color: #333;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 30px;
        margin-bottom: 30px;
        text-align: center;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      }

      .header h1 {
        font-size: 2.5em;
        background: linear-gradient(135deg, #667eea, #764ba2);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 10px;
      }

      .header-content {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 20px;
        margin-bottom: 20px;
      }

      .pulse-logo {
        height: 60px;
        width: auto;
      }

      .gold-cup {
        color: #ffd700;
        font-size: 1.2em;
        margin-left: 8px;
        display: inline-block;
        animation: sparkle 2s ease-in-out infinite;
      }

      @keyframes sparkle {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      .header p {
        font-size: 1.2em;
        color: #666;
        margin-bottom: 20px;
      }

      .controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 20px;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
      }

      .control-group label {
        font-weight: 600;
        color: #555;
        font-size: 0.9em;
      }

      select,
      input {
        padding: 10px 15px;
        border: 2px solid #e0e0e0;
        border-radius: 10px;
        background: white;
        font-size: 14px;
        transition: all 0.3s ease;
        min-width: 120px;
      }

      select:focus,
      input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      .dashboard {
        display: grid;
        gap: 25px;
        grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
      }

      .card {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 25px;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }

      .card:hover {
        transform: translateY(-5px);
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
      }

      .card h3 {
        font-size: 1.4em;
        margin-bottom: 20px;
        color: #333;
        text-align: center;
        padding-bottom: 10px;
        border-bottom: 2px solid #f0f0f0;
      }

      .chart-container {
        position: relative;
        height: 400px;
        margin-bottom: 20px;
      }

      .table-container {
        overflow-x: auto;
        margin-top: 20px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        background: white;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
      }

      th,
      td {
        padding: 12px 15px;
        text-align: left;
        border-bottom: 1px solid #f0f0f0;
      }

      th {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        font-weight: 600;
        text-transform: uppercase;
        font-size: 0.85em;
        letter-spacing: 0.5px;
      }

      tr:hover {
        background-color: #f8f9ff;
      }

      .metric-value {
        font-weight: 600;
        padding: 4px 8px;
        border-radius: 6px;
        display: inline-block;
        min-width: 60px;
        text-align: center;
      }

      .metric-high {
        background: linear-gradient(135deg, #4facfe, #00f2fe);
        color: white;
      }

      .metric-medium {
        background: linear-gradient(135deg, #43e97b, #38f9d7);
        color: white;
      }

      .metric-low {
        background: linear-gradient(135deg, #fa709a, #fee140);
        color: white;
      }

      .summary-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin-bottom: 25px;
      }

      .stat-card {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 20px;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
      }

      .stat-value {
        font-size: 2em;
        font-weight: bold;
        margin-bottom: 5px;
      }

      .stat-label {
        font-size: 0.9em;
        opacity: 0.9;
      }

      .model-type-badge {
        display: inline-block;
        padding: 4px 10px;
        border-radius: 15px;
        font-size: 0.8em;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .llm-badge {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
      }

      .baseline-badge {
        background: linear-gradient(135deg, #ffecd2, #fcb69f);
        color: #8b4513;
      }

      .loading {
        text-align: center;
        padding: 50px;
        font-size: 1.2em;
        color: #666;
      }

      .no-data {
        text-align: center;
        padding: 40px;
        color: #888;
        font-style: italic;
      }

      @media (max-width: 768px) {
        .dashboard {
          grid-template-columns: 1fr;
        }

        .controls {
          flex-direction: column;
          align-items: stretch;
        }

        .control-group {
          align-items: stretch;
        }

        .header-content {
          flex-direction: column;
          gap: 10px;
        }

        .header h1 {
          font-size: 2em;
          text-align: center;
        }

        .pulse-logo {
          height: 40px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="header-content">
          <img src="pulse_logo.svg" alt="PULSE Logo" class="pulse-logo" />
          <h1>ICU Time-Series Prediction Benchmark</h1>
        </div>
        <p>
          Comprehensive comparison of LLMs and baseline models on ICU prediction
          tasks
        </p>

        <div class="controls">
          <div class="control-group">
            <label>Task</label>
            <select id="taskFilter">
              <option value="all">All Tasks</option>
            </select>
          </div>
          <div class="control-group">
            <label>Dataset</label>
            <select id="datasetFilter">
              <option value="all">All Datasets</option>
            </select>
          </div>
          <div class="control-group">
            <label>Model Type</label>
            <select id="modelTypeFilter">
              <option value="all">All Models</option>
              <option value="llm">LLMs Only</option>
              <option value="baseline">Baselines Only</option>
            </select>
          </div>
          <div class="control-group">
            <label>Primary Metric</label>
            <select id="primaryMetric">
              <option value="auroc">AUROC</option>
              <option value="auprc">AUPRC</option>
              <option value="mcc">MCC</option>
              <option value="f1_score">F1 Score</option>
            </select>
          </div>
        </div>
      </div>

      <div class="summary-stats" id="summaryStats">
        <div class="stat-card">
          <div class="stat-value" id="totalModels">-</div>
          <div class="stat-label">Total Models</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="totalTasks">-</div>
          <div class="stat-label">Tasks</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="totalDatasets">-</div>
          <div class="stat-label">Datasets</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="bestModel">-</div>
          <div class="stat-label">Best Model</div>
        </div>
      </div>

      <div class="dashboard">
        <div class="card">
          <h3>Model Performance Comparison</h3>
          <div class="chart-container">
            <canvas id="performanceChart"></canvas>
          </div>
        </div>

        <div class="card">
          <h3>Task-wise Performance</h3>
          <div class="chart-container">
            <canvas id="taskChart"></canvas>
          </div>
        </div>

        <div class="card">
          <h3>LLM vs Baseline Comparison</h3>
          <div class="chart-container">
            <canvas id="comparisonChart"></canvas>
          </div>
        </div>

        <div class="card">
          <h3>Detailed Results Table</h3>
          <div class="table-container">
            <table id="resultsTable">
              <thead>
                <tr>
                  <th>Model</th>
                  <th>Type</th>
                  <th>Task</th>
                  <th>Dataset</th>
                  <th>AUROC</th>
                  <th>AUPRC</th>
                  <th>MCC</th>
                  <th>F1 Score</th>
                </tr>
              </thead>
              <tbody id="resultsTableBody">
                <tr>
                  <td colspan="8" class="loading">
                    Load your JSON data to see results
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <script>
      console.log("Script loaded successfully");
      let benchmarkData = [];
      let charts = {};

      // Baseline model identifiers
      const baselineModels = [
        "CNN",
        "LSTM",
        "GRU",
        "XGBoost",
        "LightGBM",
        "RandomForest",
        "Inceptiontime",
      ];

      function isBaselineModel(modelId) {
        return baselineModels.some((baseline) =>
          modelId.toLowerCase().includes(baseline.toLowerCase())
        );
      }

      function getModelType(modelId) {
        return isBaselineModel(modelId) ? "baseline" : "llm";
      }

      // Auto-load results.json on page load
      async function loadResultsJSON() {
        console.log("Attempting to load results.json...");
        try {
          const response = await fetch("results.json");
          console.log("Fetch response:", response);
          console.log("Response status:", response.status);
          console.log("Response ok:", response.ok);

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          console.log("Data loaded successfully:", data);
          console.log("Data type:", typeof data);
          console.log("Is array?", Array.isArray(data));
          console.log("Has results property?", data.hasOwnProperty("results"));

          // Handle both array format and {results: [...]} format
          if (Array.isArray(data)) {
            benchmarkData = data;
            console.log("Using data directly as array");
          } else if (data.results && Array.isArray(data.results)) {
            benchmarkData = data.results;
            console.log("Using data.results as array");
          } else {
            throw new Error(
              "Invalid JSON format. Expected array or {results: [...]}"
            );
          }

          console.log("Benchmark data:", benchmarkData);
          console.log("Benchmark data length:", benchmarkData.length);
          initializeDashboard();
        } catch (error) {
          console.error("Error loading results.json:", error);

          // Show error message in the table
          const tbody = document.getElementById("resultsTableBody");
          tbody.innerHTML = `
                    <tr>
                        <td colspan="8" class="no-data">
                            Error loading results.json: ${error.message}<br>
                            Please ensure results.json is in the same folder as index.html
                        </td>
                    </tr>
                `;

          // Also show in summary stats
          document.getElementById("totalModels").textContent = "Error";
          document.getElementById("totalTasks").textContent = "Error";
          document.getElementById("totalDatasets").textContent = "Error";
          document.getElementById("bestModel").textContent = "Error";
        }
      }

      // Load data when page loads
      window.addEventListener("load", () => {
        console.log("Window load event fired");
        loadResultsJSON();
      });

      function initializeDashboard() {
        console.log("Initializing dashboard with data:", benchmarkData);
        console.log("Data length:", benchmarkData.length);
        populateFilters();
        updateSummaryStats();
        createCharts();
        updateTable();
        setupEventListeners();
      }

      function populateFilters() {
        console.log("Populating filters with data:", benchmarkData);

        // Filter out any entries with missing task_id or dataset and log them
        const validData = benchmarkData.filter((d, index) => {
          if (!d.task_id || !d.dataset) {
            console.warn(`Entry ${index} missing required fields:`, d);
            return false;
          }
          return true;
        });

        console.log(
          "Valid data count:",
          validData.length,
          "out of",
          benchmarkData.length
        );

        const tasks = [...new Set(validData.map((d) => d.task_id))];
        const datasets = [...new Set(validData.map((d) => d.dataset))];

        console.log("Unique tasks:", tasks);
        console.log("Unique datasets:", datasets);

        const taskFilter = document.getElementById("taskFilter");
        const datasetFilter = document.getElementById("datasetFilter");

        taskFilter.innerHTML = '<option value="all">All Tasks</option>';
        datasetFilter.innerHTML = '<option value="all">All Datasets</option>';

        tasks.forEach((task) => {
          if (task) {
            // Additional safety check
            taskFilter.innerHTML += `<option value="${task}">${
              task.charAt(0).toUpperCase() + task.slice(1)
            }</option>`;
          }
        });

        datasets.forEach((dataset) => {
          if (dataset) {
            // Additional safety check
            datasetFilter.innerHTML += `<option value="${dataset}">${dataset.toUpperCase()}</option>`;
          }
        });
      }

      function getFilteredData() {
        const taskFilter = document.getElementById("taskFilter").value;
        const datasetFilter = document.getElementById("datasetFilter").value;
        const modelTypeFilter =
          document.getElementById("modelTypeFilter").value;

        return benchmarkData.filter((d) => {
          // Safety checks for undefined values
          if (!d.task_id || !d.dataset || !d.model_id) {
            return false;
          }

          const taskMatch = taskFilter === "all" || d.task_id === taskFilter;
          const datasetMatch =
            datasetFilter === "all" || d.dataset === datasetFilter;
          const modelType = getModelType(d.model_id);
          const modelTypeMatch =
            modelTypeFilter === "all" || modelType === modelTypeFilter;

          return taskMatch && datasetMatch && modelTypeMatch;
        });
      }

      function updateSummaryStats() {
        const filteredData = getFilteredData();
        const models = [...new Set(filteredData.map((d) => d.model_id))];
        const tasks = [...new Set(filteredData.map((d) => d.task_id))];
        const datasets = [...new Set(filteredData.map((d) => d.dataset))];

        const primaryMetric = document.getElementById("primaryMetric").value;
        console.log(
          "Updating summary stats with primary metric:",
          primaryMetric
        );

        // Debug: Log all scores for the selected metric
        const allScores = filteredData.map((d) => ({
          model: d.model_id,
          score: d.metrics_summary?.overall?.[primaryMetric],
          rawMetrics: d.metrics_summary?.overall,
        }));
        console.log(`All ${primaryMetric} scores:`, allScores);

        const bestResult = filteredData.reduce((best, current) => {
          const currentScore =
            current.metrics_summary?.overall?.[primaryMetric];
          const bestScore = best?.metrics_summary?.overall?.[primaryMetric];

          // Handle cases where scores might be null/undefined
          if (currentScore === undefined || currentScore === null) return best;
          if (best === null || bestScore === undefined || bestScore === null)
            return current;

          return currentScore > bestScore ? current : best;
        }, null);

        // Alternative approach: Find the model with the highest average score
        const modelAverages = {};
        filteredData.forEach((d) => {
          const score = d.metrics_summary?.overall?.[primaryMetric];
          if (score !== undefined && score !== null) {
            if (!modelAverages[d.model_id]) {
              modelAverages[d.model_id] = { scores: [], entries: [] };
            }
            modelAverages[d.model_id].scores.push(score);
            modelAverages[d.model_id].entries.push(d);
          }
        });

        // Find model with highest average score
        let bestModelByAverage = null;
        let bestAverageScore = -Infinity;
        Object.keys(modelAverages).forEach((modelId) => {
          const scores = modelAverages[modelId].scores;
          const avgScore =
            scores.reduce((sum, score) => sum + score, 0) / scores.length;
          if (avgScore > bestAverageScore) {
            bestAverageScore = avgScore;
            bestModelByAverage = modelId;
          }
        });

        console.log(
          "Best result by single entry:",
          bestResult?.model_id,
          "with score:",
          bestResult?.metrics_summary?.overall?.[primaryMetric]
        );
        console.log(
          "Best model by average score:",
          bestModelByAverage,
          "with avg score:",
          bestAverageScore
        );

        // Use the model with best average score for display
        const displayBestModel = bestModelByAverage || bestResult?.model_id;

        document.getElementById("totalModels").textContent = models.length;
        document.getElementById("totalTasks").textContent = tasks.length;
        document.getElementById("totalDatasets").textContent = datasets.length;

        // Display best model with gold cup
        const bestModelElement = document.getElementById("bestModel");
        if (displayBestModel) {
          bestModelElement.innerHTML = `${displayBestModel} <span class="gold-cup">🏆</span>`;
        } else {
          bestModelElement.textContent = "-";
        }
      }

      function createCharts() {
        createPerformanceChart();
        createTaskChart();
        createComparisonChart();
      }

      function createPerformanceChart() {
        const ctx = document
          .getElementById("performanceChart")
          .getContext("2d");
        const filteredData = getFilteredData();
        const primaryMetric = document.getElementById("primaryMetric").value;

        // Group by model and calculate average performance
        const modelPerformance = {};
        filteredData.forEach((d) => {
          if (!modelPerformance[d.model_id]) {
            modelPerformance[d.model_id] = {
              scores: [],
              type: getModelType(d.model_id),
            };
          }
          const score = d.metrics_summary?.overall?.[primaryMetric];
          if (score !== undefined) {
            modelPerformance[d.model_id].scores.push(score);
          }
        });

        const models = Object.keys(modelPerformance);
        const avgScores = models.map((model) => {
          const scores = modelPerformance[model].scores;
          return scores.reduce((sum, score) => sum + score, 0) / scores.length;
        });

        const colors = models.map((model) =>
          modelPerformance[model].type === "llm"
            ? "rgba(102, 126, 234, 0.8)"
            : "rgba(252, 182, 159, 0.8)"
        );

        if (charts.performance) {
          charts.performance.destroy();
        }

        charts.performance = new Chart(ctx, {
          type: "bar",
          data: {
            labels: models,
            datasets: [
              {
                label: primaryMetric.toUpperCase(),
                data: avgScores,
                backgroundColor: colors,
                borderColor: colors.map((color) => color.replace("0.8", "1")),
                borderWidth: 2,
                borderRadius: 8,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false,
              },
            },
            scales: {
              y: {
                beginAtZero: primaryMetric === "mcc" ? false : true,
                min: primaryMetric === "mcc" ? -1 : 0,
                max: 1,
              },
              x: {
                ticks: {
                  maxRotation: 45,
                },
              },
            },
          },
        });
      }

      function createTaskChart() {
        const ctx = document.getElementById("taskChart").getContext("2d");
        const filteredData = getFilteredData();
        const primaryMetric = document.getElementById("primaryMetric").value;

        // Group by task and calculate average performance
        const taskPerformance = {};
        filteredData.forEach((d) => {
          if (!taskPerformance[d.task_id]) {
            taskPerformance[d.task_id] = [];
          }
          const score = d.metrics_summary?.overall?.[primaryMetric];
          if (score !== undefined) {
            taskPerformance[d.task_id].push(score);
          }
        });

        const tasks = Object.keys(taskPerformance);
        const avgScores = tasks.map((task) => {
          const scores = taskPerformance[task];
          return scores.reduce((sum, score) => sum + score, 0) / scores.length;
        });

        if (charts.task) {
          charts.task.destroy();
        }

        charts.task = new Chart(ctx, {
          type: "doughnut",
          data: {
            labels: tasks.map(
              (task) => task.charAt(0).toUpperCase() + task.slice(1)
            ),
            datasets: [
              {
                data: avgScores,
                backgroundColor: [
                  "rgba(102, 126, 234, 0.8)",
                  "rgba(118, 75, 162, 0.8)",
                  "rgba(255, 99, 132, 0.8)",
                  "rgba(54, 162, 235, 0.8)",
                  "rgba(255, 205, 86, 0.8)",
                ],
                borderWidth: 3,
                borderColor: "#fff",
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: "bottom",
              },
            },
          },
        });
      }

      function createComparisonChart() {
        const ctx = document.getElementById("comparisonChart").getContext("2d");
        const filteredData = getFilteredData();
        const primaryMetric = document.getElementById("primaryMetric").value;

        // Separate LLMs and baselines
        const llmScores = [];
        const baselineScores = [];

        filteredData.forEach((d) => {
          const score = d.metrics_summary?.overall?.[primaryMetric];
          if (score !== undefined) {
            if (getModelType(d.model_id) === "llm") {
              llmScores.push(score);
            } else {
              baselineScores.push(score);
            }
          }
        });

        const llmAvg =
          llmScores.length > 0
            ? llmScores.reduce((sum, score) => sum + score, 0) /
              llmScores.length
            : 0;
        const baselineAvg =
          baselineScores.length > 0
            ? baselineScores.reduce((sum, score) => sum + score, 0) /
              baselineScores.length
            : 0;

        if (charts.comparison) {
          charts.comparison.destroy();
        }

        charts.comparison = new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["LLMs", "Baseline Models"],
            datasets: [
              {
                label: `Average ${primaryMetric.toUpperCase()}`,
                data: [llmAvg, baselineAvg],
                backgroundColor: [
                  "rgba(102, 126, 234, 0.8)",
                  "rgba(252, 182, 159, 0.8)",
                ],
                borderColor: [
                  "rgba(102, 126, 234, 1)",
                  "rgba(252, 182, 159, 1)",
                ],
                borderWidth: 2,
                borderRadius: 8,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false,
              },
            },
            scales: {
              y: {
                beginAtZero: primaryMetric === "mcc" ? false : true,
                min: primaryMetric === "mcc" ? -1 : 0,
                max: 1,
              },
            },
          },
        });
      }

      function updateTable() {
        const filteredData = getFilteredData();
        const tbody = document.getElementById("resultsTableBody");

        if (filteredData.length === 0) {
          tbody.innerHTML =
            '<tr><td colspan="8" class="no-data">No data matches the current filters</td></tr>';
          return;
        }

        tbody.innerHTML = "";

        // Sort by primary metric descending
        const primaryMetric = document.getElementById("primaryMetric").value;
        filteredData.sort((a, b) => {
          const aScore = a.metrics_summary?.overall?.[primaryMetric] || 0;
          const bScore = b.metrics_summary?.overall?.[primaryMetric] || 0;
          return bScore - aScore;
        });

        filteredData.forEach((d) => {
          const metrics = d.metrics_summary?.overall || {};
          const modelType = getModelType(d.model_id);

          // Safety check for required fields
          if (!d.model_id || !d.task_id || !d.dataset) {
            console.warn("Skipping entry with missing required fields:", d);
            return;
          }

          const row = document.createElement("tr");
          row.innerHTML = `
                    <td>${d.model_id}</td>
                    <td><span class="model-type-badge ${modelType}-badge">${modelType.toUpperCase()}</span></td>
                    <td>${
                      d.task_id.charAt(0).toUpperCase() + d.task_id.slice(1)
                    }</td>
                    <td>${d.dataset.toUpperCase()}</td>
                    <td><span class="metric-value ${getMetricClass(
                      metrics.auroc
                    )}">${(metrics.auroc || 0).toFixed(3)}</span></td>
                    <td><span class="metric-value ${getMetricClass(
                      metrics.auprc
                    )}">${(metrics.auprc || 0).toFixed(3)}</span></td>
                    <td><span class="metric-value ${getMetricClass(
                      metrics.mcc
                    )}">${(metrics.mcc || 0).toFixed(3)}</span></td>
                    <td><span class="metric-value ${getMetricClass(
                      metrics.f1_score
                    )}">${(metrics.f1_score || 0).toFixed(3)}</span></td>
                `;
          tbody.appendChild(row);
        });
      }

      function getMetricClass(value) {
        if (value >= 0.8) return "metric-high";
        if (value >= 0.6) return "metric-medium";
        if (value >= 0.0) return "metric-low";
        return "metric-low"; // For negative values (like MCC)
      }

      function setupEventListeners() {
        [
          "taskFilter",
          "datasetFilter",
          "modelTypeFilter",
          "primaryMetric",
        ].forEach((id) => {
          document.getElementById(id).addEventListener("change", () => {
            updateSummaryStats();
            createCharts();
            updateTable();
          });
        });
      }
    </script>
  </body>
</html>
